
# TODO '_', '$'
# TODO return
# TODO sort?

tokens:
	operators, brackets, and assignment:
		+ - * / // % to , ! == != <= >= < > . or and not select ( )
		= += -= *=
	command keywords:
		select from where for in if else elif break continue bychance print pass fail done return
	comment markers:
		# /* */
	tokens:
		variable names: [a-zA-Z~][a-zA-Z0-9_~]*
		the nameless variable: _
		the odds of the path reaching the current point, as a fraction: $
		integers: [0-9][0-9]*
		strings: Use "" only, permits \n \r \t \\ \", must be single-line only.
        empty list: ()
	special tokens (generated by compiler):
		'\n' and '\0', for linebreak and EOF.
		'{' and '}', for indent+ and indent-.

order of operations (top of the list executes first):
	( )
	unary operators: ! - select not
	* // % / .
	+ -
	to
	,
    in
	== != <= >= < >
	and
	or


comments are either a '#' until the end of a line, or a multi-line comment starting with '/*' ending with '*/'
note that linebreaks are considered part of multi-line comments, and multi-line comments can begin and end anywhere. Thus, ending a line with '/*' and beginning the next line with '*/' allows you to turn 2 lines into 1, though this technique is discouraged. (This also applies to indentation. Effectively, the lexer ignores any multi-line comment from the file entirely, including all characters in between the start and end.)


prog = {command} .
block = "{" {command} "}" .

var = <see token list>. Includes special variables: '_' and '$'.
int = <see token list>
str = <see token list>

command = "\n"
		| "select" var "from" expr ["where" expr] "\n"
		| "pass" "\n"
		| "fail" "\n"
		| "done" "\n"
		| "return" expr "\n"
		| "for" var ("in" | "from") expr "\n" block
		| "if" expr "\n" block [elseOptions]
		| "bychance" expr "\n"
		| "print" expr "\n"
		| var assignOp expr .

assignOp = "="



elseOptions = "elif" expr block elseOptions
			| "else" expr block .


expr = expr1
expr1 = expr2 {"or" expr2}
expr2 = expr3 {"and" expr3}
expr3 = expr3B {("==" | "!=" | "<=" | ">=" | "<=" | ">" | "<") expr3B}
expr3B = expr4 {"in" expr4}
expr4 = expr5 {"," [expr5]} # Special case: if '[expr5]' is omitted, assume '()' instead
expr5 = expr6 {"to" expr6}
expr6 = expr7 {("+" | "-") expr7}
expr7 = expr8 {("*" | "//" | "%" | "/" | ".") expr8}
expr8 = ["!" | "-" | "select" | "not"] expr9
expr9 = int | var | string | "(" expr1 ")" | "(" expr1 "," ")" | "()"






Semantics:
	

# TODO